<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <!-- Responsive meta tag -->
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
  <title>Combined Biblical & US/UK Cities Map</title>
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.3/dist/leaflet.css" />
  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css" />
  <!-- Leaflet Awesome Markers CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Leaflet.awesome-markers/2.0.2/leaflet.awesome-markers.css" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
    }
    #map {
      width: 100%;
      height: 100%;
    }
    /* Desktop fixed filter panel */
    #filter-panel-fixed {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 1100;
      background: white;
      padding: 10px;
      border: 1px solid #ccc;
      max-height: 90%;
      overflow-y: auto;
      font-size: 0.9rem;
      width: 280px;
    }
    /* Mobile offcanvas panel overrides */
    @media (max-width: 768px) {
      .offcanvas { width: 80% !important; }
      .offcanvas-body {
        max-height: calc(100vh - 60px);
        overflow-y: auto;
      }
      .leaflet-popup-content-wrapper {
        max-width: 90% !important;
        font-size: 0.85rem;
      }
      .leaflet-popup-tip {
        display: none;
      }
    }
    /* Limit popup size */
    .leaflet-popup-content {
      max-height: 300px;
      overflow-y: auto;
    }
  </style>
</head>
<body>
  <!-- Map container -->
  <div id="map"></div>

  <!-- Desktop fixed filter panel -->
  <div id="filter-panel-fixed" class="d-none d-lg-block shadow">
    <h5>Filter Markers</h5>
    <!-- Toggle controls – markers will load only when toggled on -->
    <div class="mb-2 form-check">
      <input type="checkbox" id="toggleUSUK" class="form-check-input">
      <label for="toggleUSUK" class="form-check-label">Show US‑UK Cities</label>
    </div>
    <div class="mb-2 form-check">
      <input type="checkbox" id="toggleUSBiblical" class="form-check-input">
      <label for="toggleUSBiblical" class="form-check-label">Show US Biblical Cities</label>
    </div>
    <!-- Testament filter control -->
    <div class="mb-2">
      <strong>Testament:</strong>
      <select id="testamentFilter" class="form-select form-select-sm">
        <option value="both" selected>Both</option>
        <option value="old">Old Testament</option>
        <option value="new">New Testament</option>
      </select>
    </div>
    <!-- Biblical Reference Filter section -->
    <div class="mb-2">
      <strong>Biblical Reference Filter:</strong>
      <select id="bibRefFilterType" class="form-select form-select-sm">
        <option value="none" selected>None</option>
        <option value="book">Book/Chapter</option>
        <option value="parsha">Parsha</option>
      </select>
      <div id="bibRefBookChapter" style="display: none; margin-top: 5px;">
        <select id="bibRefBook" class="form-select form-select-sm"></select>
        <input type="number" id="bibRefChapter" class="form-control form-control-sm mt-1" placeholder="Chapter #" min="1">
      </div>
      <div id="bibRefParsha" style="display: none; margin-top: 5px;">
        <select id="bibRefParshaSelect" class="form-select form-select-sm"></select>
      </div>
    </div>
    <!-- US States filter panel -->
    <div class="mb-2">
      <strong>US States:</strong>
      <div id="us-states-filter"></div>
      <button id="selectAllStates" class="btn btn-sm btn-primary mt-2">Select All States</button>
    </div>
    <!-- Zoom All Button -->
    <div class="mt-2">
      <button id="zoomAllBtn" class="btn btn-sm btn-warning">Zoom to All Markers</button>
    </div>
    <!-- Search Box -->
    <div class="mt-3">
      <label for="citySearch" class="form-label">Search (by group):</label>
      <input type="text" id="citySearch" class="form-control form-control-sm" placeholder="Type to search...">
      <ul id="searchResults"></ul>
    </div>
  </div>

  <!-- Mobile offcanvas filter panel -->
  <div class="offcanvas offcanvas-start d-lg-none" tabindex="-1" id="filterPanelOffcanvas" aria-labelledby="filterPanelOffcanvasLabel">
    <div class="offcanvas-header">
      <h5 class="offcanvas-title" id="filterPanelOffcanvasLabel">Filter Markers</h5>
      <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close"></button>
    </div>
    <div class="offcanvas-body">
      <!-- Mobile controls mirror desktop controls -->
      <div class="mb-2 form-check">
        <input type="checkbox" id="toggleUSUK_mobile" class="form-check-input">
        <label for="toggleUSUK_mobile" class="form-check-label">Show US‑UK Cities</label>
      </div>
      <div class="mb-2 form-check">
        <input type="checkbox" id="toggleUSBiblical_mobile" class="form-check-input">
        <label for="toggleUSBiblical_mobile" class="form-check-label">Show US Biblical Cities</label>
      </div>
      <div class="mb-2">
        <strong>Testament:</strong>
        <select id="testamentFilter_mobile" class="form-select form-select-sm">
          <option value="both" selected>Both</option>
          <option value="old">Old Testament</option>
          <option value="new">New Testament</option>
        </select>
      </div>
      <!-- Biblical Reference Filter for Mobile -->
      <div class="mb-2">
        <strong>Biblical Reference Filter:</strong>
        <select id="bibRefFilterType_mobile" class="form-select form-select-sm">
          <option value="none" selected>None</option>
          <option value="book">Book/Chapter</option>
          <option value="parsha">Parsha</option>
        </select>
        <div id="bibRefBookChapter_mobile" style="display: none; margin-top: 5px;">
          <select id="bibRefBook_mobile" class="form-select form-select-sm"></select>
          <input type="number" id="bibRefChapter_mobile" class="form-control form-control-sm mt-1" placeholder="Chapter #" min="1">
        </div>
        <div id="bibRefParsha_mobile" style="display: none; margin-top: 5px;">
          <select id="bibRefParshaSelect_mobile" class="form-select form-select-sm"></select>
        </div>
      </div>
      <div class="mb-2">
        <strong>US States:</strong>
        <div id="us-states-filter-mobile"></div>
        <button id="selectAllStates_mobile" class="btn btn-sm btn-primary mt-2">Select All States</button>
      </div>
      <div class="mt-2">
        <button id="zoomAllBtn_mobile" class="btn btn-sm btn-warning">Zoom to All Markers</button>
      </div>
      <div class="mt-3">
        <label for="citySearch_mobile" class="form-label">Search (by group):</label>
        <input type="text" id="citySearch_mobile" class="form-control form-control-sm" placeholder="Type to search...">
        <ul id="searchResults_mobile"></ul>
      </div>
    </div>
  </div>

  <!-- Mobile filter toggle button -->
  <button class="btn btn-primary d-lg-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#filterPanelOffcanvas" aria-controls="filterPanelOffcanvas" style="position: absolute; top: 10px; right: 10px; z-index: 1200;">
    Filters
  </button>

  <!-- External Libraries -->
  <script src="https://code.jquery.com/jquery-1.12.4.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.3/dist/leaflet.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Leaflet.awesome-markers/2.0.2/leaflet.awesome-markers.js"></script>

  <!-- Main Script -->
  <script>
  (function() {
    /*************************************
     * GLOBAL VARIABLES & POPUP OPTIONS
     *************************************/
    const popupOptions = {
      maxWidth: 250,
      autoPan: true,
      autoPanPadding: L.point(10, 100),
      offset: L.point(0, -10),
      closeOnClick: false,
      autoClose: false
    };

    const map = L.map('map').setView([39.50, -98.35], 4);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; OpenStreetMap contributors',
      maxZoom: 18
    }).addTo(map);

    // Layer groups.
    const usUkLayerGroup = L.layerGroup();
    const oldBiblicalLayerGroup = L.layerGroup();
    const newBiblicalLayerGroup = L.layerGroup();
    const bothBiblicalLayerGroup = L.layerGroup();

    // Marker arrays and data objects.
    let usUkMarkers = [];
    let usBiblicalMarkers = [];
    let usUkLoaded = false;
    let usBiblicalLoaded = false;
    let biblicalDataMap = {}; // keyed by groupKey
    let usStatesSet = new Set();

    // External JSON data for biblical books and parsha filtering.
    let booksData = {};       
    let parshaDataLoaded = {};  

    // Icon definitions.
    const iconCityUS = L.AwesomeMarkers.icon({ icon: 'info-sign', markerColor: 'blue', prefix: 'glyphicon' });
    const iconCityUK = L.AwesomeMarkers.icon({ icon: 'info-sign', markerColor: 'red', prefix: 'glyphicon' });
    const iconUSBiblical = L.AwesomeMarkers.icon({ icon: 'info-sign', markerColor: 'purple', prefix: 'glyphicon' });
    const iconBiblical = L.AwesomeMarkers.icon({ icon: 'info-sign', markerColor: 'green', prefix: 'glyphicon' });
    const highlightIcon = L.AwesomeMarkers.icon({ icon: 'star', markerColor: 'orange', prefix: 'glyphicon' });

    /*************************************
     * UTILITY FUNCTIONS
     *************************************/
    function getBaseGroup(name) {
      if (!name) return "";
      let cleaned = name.split("/")[0].trim().toLowerCase();
      cleaned = cleaned.replace(/\s*\d+$/, "");
      cleaned = cleaned.replace(/\(.*\)/, "").trim();
      return cleaned;
    }
    function titleCase(str) {
  return str.replace(/\w\S*/g, function(txt) {
    return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
  });
}
    function parseCoordinates(coordStr, swap = false) {
      coordStr = coordStr.trim();
      if (!coordStr) return [];
      const pairs = coordStr.split(" ").filter(s => s.trim() !== "");
      return pairs.map(pair => {
        const coords = pair.split(",");
        return swap ? [parseFloat(coords[1]), parseFloat(coords[0])] : [parseFloat(coords[0]), parseFloat(coords[1])];
      });
    }
    function normalizeTestament(testament) {
      const t = testament.trim().toLowerCase();
      if (t.indexOf("old") !== -1) return "old";
      if (t.indexOf("new") !== -1) return "new";
      return "both";
    }
    // Normalize biblical book names (e.g. "jonahum" to "jonah").
    // Normalizes biblical book names so that variations like "ii kings", "2 kings", or "2kings" are all returned as "II Kings" (and similarly for Samuel and Chronicles).
// Normalize biblical book names so that variations like "ii kings", "2 kings", or "2kings" are returned as "II Kings" (and similarly for Samuel and Chronicles).
function normalizeBiblicalBook(book) {
  const b = book.trim().toLowerCase();
  if (b === "jonahum") return "Jonah";
  if (b === "ii kings" || b === "2 kings" || b === "2kings") return "II Kings";
  if (b === "ii samuel" || b === "2 samuel" || b === "2samuel") return "II Samuel";
  if (b === "ii chronicles" || b === "2 chronicles" || b === "2chronicles") return "II Chronicles";
  // For all other books, return in Title Case.
  return b.split(" ").map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(" ");
}
    // Parse a biblical reference (e.g., "Genesis 1:1") and normalize the book.
    function parseReference(ref) {
      const match = ref.match(/^([\D]+)[\s:]+(\d+):(\d+)/);
      if (!match) return null;
      const book = normalizeBiblicalBook(match[1].trim());
      return { book: book, chapter: parseInt(match[2]), verse: parseInt(match[3]) };
    }
    // Parse a reference range string (e.g., "Genesis 1:1-2:3").
    function parseRange(rangeStr) {
      const match = rangeStr.match(/^([\D]+)[\s]+(\d+):(\d+)-(\d+):(\d+)/);
      if (!match) return null;
      return {
        book: match[1].trim(),
        startChapter: parseInt(match[2]),
        startVerse: parseInt(match[3]),
        endChapter: parseInt(match[4]),
        endVerse: parseInt(match[5])
      };
    }
    function refInRange(ref, range) {
      if (ref.book.toLowerCase() !== range.book.toLowerCase()) return false;
      if (ref.chapter < range.startChapter) return false;
      if (ref.chapter > range.endChapter) return false;
      if (ref.chapter === range.startChapter && ref.verse < range.startVerse) return false;
      if (ref.chapter === range.endChapter && ref.verse > range.endVerse) return false;
      return true;
    }
    // Build biblical popup content and highlight matching verses based on the "Book/Chapter" filter.
// If the filter type is "book" and no chapter is provided, then all references from the selected book will be highlighted.
function buildBiblicalPopupContent(refString) {
  if (!refString) return "";
  const refs = refString.split(",").map(r => r.trim()).filter(r => r);
  const groups = { old: {}, new: {} };

  // Set of New Testament abbreviations (in lowercase)
  const ntAbbr = new Set([
    "matt", "mark", "luke", "john", "acts", "rom",
    "1 cor", "2 cor", "gal", "eph", "phil", "col",
    "1 thess", "2 thess", "1 tim", "2 tim", "titus",
    "philem", "heb", "james", "1 pet", "2 pet",
    "1 john", "2 john", "3 john", "jude", "rev"
  ]);

  // Get the current biblical filter settings
  const filters = getFilterSettings();
  const filterType = filters.bibRefFilterType;
  let selectedBook = null, selectedChapter = null, selectedParsha = null, parshaRange = null;
  if (filterType === "book" && filters.bibRefBook) {
    selectedBook = normalizeBiblicalBook(filters.bibRefBook);
    if (filters.bibRefChapter) {
      selectedChapter = parseInt(filters.bibRefChapter);
    }
  } else if (filterType === "parsha" && filters.bibRefParsha && parshaDataLoaded[filters.bibRefParsha]) {
    selectedParsha = filters.bibRefParsha;
    const rangeStr = parshaDataLoaded[selectedParsha]["Whole Parsha"];
    parshaRange = parseRange(rangeStr);
  }

  refs.forEach(ref => {
    const match = ref.match(/^([\D]+)[\s:]+(\d+:\d+(?:-\d+)?)$/);
    if (match) {
      const rawBook = match[1].trim();
      const normalizedBook = normalizeBiblicalBook(rawBook);
      const verses = match[2].trim();
      const testament = ntAbbr.has(normalizedBook.toLowerCase()) ? "new" : "old";

      // Determine if this reference should be highlighted.
      let highlight = false;
      if (filterType === "book" && selectedBook && normalizedBook === selectedBook) {
        if (selectedChapter) {
          // If a chapter is provided, highlight only if the chapter matches.
          const chapMatch = ref.match(/^([\D]+)[\s:]+(\d+):/);
          if (chapMatch && parseInt(chapMatch[2]) === selectedChapter) {
            highlight = true;
          }
        } else {
          // No chapter provided—highlight all references from the selected book.
          highlight = true;
        }
      } else if (filterType === "parsha" && parshaRange) {
        // For parsha filtering, highlight if the reference falls within the parsha range.
        const parsedRef = parseReference(ref);
        if (parsedRef && refInRange(parsedRef, parshaRange)) {
          highlight = true;
        }
      }

      const displayVerses = highlight ? `<span style="background:yellow">${verses}</span>` : verses;
      if (!groups[testament][normalizedBook]) {
        groups[testament][normalizedBook] = [];
      }
      groups[testament][normalizedBook].push(displayVerses);
    }
  });

  let html = "";
  if (Object.keys(groups.old).length > 0) {
    html += "<div><h6>Old Testament</h6><ul>";
    for (const book in groups.old) {
      html += `<li><strong>${book}:</strong> ${groups.old[book].join(", ")}</li>`;
    }
    html += "</ul></div>";
  }
  if (Object.keys(groups.new).length > 0) {
    html += "<div><h6>New Testament</h6><ul>";
    for (const book in groups.new) {
      html += `<li><strong>${book}:</strong> ${groups.new[book].join(", ")}</li>`;
    }
    html += "</ul></div>";
  }
  return html;
}
    // Returns true if a marker's biblical references pass the current biblical filter.
    // Update marker filtering so that when the filter type is "book", it returns true if at least one reference
// in the marker matches the selected book. If a chapter is provided, then it requires an exact chapter match.
function markerPassesBibRefFilter(marker) {
  const filters = getFilterSettings();
  if (filters.bibRefFilterType === "none") return true;
  const refs = marker.myData.biblicalReferences;
  if (!refs) return false;
  const refList = refs.split(",").map(r => r.trim()).filter(r => r);
  
  if (filters.bibRefFilterType === "book") {
    const selectedBook = normalizeBiblicalBook(filters.bibRefBook);
    if (!selectedBook) return true;
    if (!filters.bibRefChapter) {
      // No chapter provided—pass if any reference starts with the selected book.
      return refList.some(ref => ref.toLowerCase().startsWith(selectedBook.toLowerCase()));
    } else {
      const selectedChapter = parseInt(filters.bibRefChapter);
      return refList.some(ref => {
        const match = ref.match(/^([\D]+)[\s:]+(\d+):/);
        if (match) {
          const book = normalizeBiblicalBook(match[1].trim());
          const chapter = parseInt(match[2]);
          return book === selectedBook && chapter === selectedChapter;
        }
        return false;
      });
    }
  } else if (filters.bibRefFilterType === "parsha") {
    const selectedParsha = filters.bibRefParsha;
    if (!selectedParsha || !parshaDataLoaded[selectedParsha]) return true;
    const rangeStr = parshaDataLoaded[selectedParsha]["Whole Parsha"];
    const range = parseRange(rangeStr);
    if (!range) return false;
    return refList.some(ref => {
      const parsedRef = parseReference(ref);
      return parsedRef && refInRange(parsedRef, range);
    });
  }
  return true;
}

    /*************************************
     * URL FILTER FUNCTIONS
     *************************************/
    function getInitialFiltersFromUrl() {
      const params = new URLSearchParams(window.location.search);
      return {
        usuk: params.get("usuk") === "1",
        usbiblical: params.get("usbiblical") === "1",
        states: params.get("states")
          ? params.get("states").split(",").map(s => s.trim().toLowerCase())
          : null,
        testament: params.get("testament") ? normalizeTestament(params.get("testament")) : "both",
        bibRefFilterType: params.get("bibref") ? params.get("bibref") : "none",
        bibRefBook: params.get("bibrefbook") ? params.get("bibrefbook") : "",
        bibRefChapter: params.get("bibrefchapter") ? params.get("bibrefchapter") : "",
        bibRefParsha: params.get("bibrefparsha") ? params.get("bibrefparsha") : ""
      };
    }
    function updateUrlWithFilters() {
      const filters = getFilterSettings();
      const params = new URLSearchParams(window.location.search);
      params.set("usuk", filters.toggleUSUK ? "1" : "0");
      params.set("usbiblical", filters.toggleUSBiblical ? "1" : "0");
      params.set("testament", filters.testament);
      params.set("bibref", filters.bibRefFilterType);
      if (filters.bibRefFilterType === "book") {
        params.set("bibrefbook", filters.bibRefBook);
        params.set("bibrefchapter", filters.bibRefChapter);
      } else if (filters.bibRefFilterType === "parsha") {
        params.set("bibrefparsha", filters.bibRefParsha);
      }
      if (filters.selectedStates && filters.selectedStates.length > 0) {
        params.set("states", filters.selectedStates.join(","));
      } else {
        params.delete("states");
      }
      history.replaceState(null, "", "?" + params.toString());
    }
    function getFilterSettings() {
      const usUkDesktop = document.getElementById("toggleUSUK");
      const usUkMobile = document.getElementById("toggleUSUK_mobile");
      const usBiblicalDesktop = document.getElementById("toggleUSBiblical");
      const usBiblicalMobile = document.getElementById("toggleUSBiblical_mobile");
      const toggleUSUK = (usUkDesktop ? usUkDesktop.checked : false) || (usUkMobile ? usUkMobile.checked : false);
      const toggleUSBiblical = (usBiblicalDesktop ? usBiblicalDesktop.checked : false) || (usBiblicalMobile ? usBiblicalMobile.checked : false);
      const testamentFilter = document.getElementById("testamentFilter")
                                ? document.getElementById("testamentFilter").value.toLowerCase()
                                : (document.getElementById("testamentFilter_mobile") ? document.getElementById("testamentFilter_mobile").value.toLowerCase() : "both");
      const stateInputs = document.querySelectorAll("#us-states-filter input[type=checkbox], #us-states-filter-mobile input[type=checkbox]");
      let selectedStates = [];
      stateInputs.forEach(cb => { if (cb.checked) selectedStates.push(cb.value.trim().toLowerCase()); });
      const bibRefFilterType = document.getElementById("bibRefFilterType").value.toLowerCase();
      const bibRefBook = document.getElementById("bibRefBook").value;
      const bibRefChapter = document.getElementById("bibRefChapter").value;
      const bibRefParsha = document.getElementById("bibRefParshaSelect").value;
      return { toggleUSUK, toggleUSBiblical, selectedStates, testament: testamentFilter, bibRefFilterType, bibRefBook, bibRefChapter, bibRefParsha };
    }
    function applyFiltersFromUrl() {
      const initial = getInitialFiltersFromUrl();
      console.log("Applying filters from URL:", initial);
      const toggleUSUKDesktop = document.getElementById("toggleUSUK");
      const toggleUSBiblicalDesktop = document.getElementById("toggleUSBiblical");
      if (toggleUSUKDesktop) toggleUSUKDesktop.checked = initial.usuk;
      if (toggleUSBiblicalDesktop) toggleUSBiblicalDesktop.checked = initial.usbiblical;
      const toggleUSUKMobile = document.getElementById("toggleUSUK_mobile");
      const toggleUSBiblicalMobile = document.getElementById("toggleUSBiblical_mobile");
      if (toggleUSUKMobile) toggleUSUKMobile.checked = initial.usuk;
      if (toggleUSBiblicalMobile) toggleUSBiblicalMobile.checked = initial.usbiblical;
      const testamentDesktop = document.getElementById("testamentFilter");
      const testamentMobile = document.getElementById("testamentFilter_mobile");
      if (testamentDesktop) testamentDesktop.value = initial.testament;
      if (testamentMobile) testamentMobile.value = initial.testament;
      if (initial.bibRefFilterType) {
        document.getElementById("bibRefFilterType").value = initial.bibRefFilterType;
        if (initial.bibRefFilterType === "book") {
          document.getElementById("bibRefBookChapter").style.display = "block";
          document.getElementById("bibRefParsha").style.display = "none";
          document.getElementById("bibRefBook").value = initial.bibRefBook;
          document.getElementById("bibRefChapter").value = initial.bibRefChapter;
        } else if (initial.bibRefFilterType === "parsha") {
          document.getElementById("bibRefParsha").style.display = "block";
          document.getElementById("bibRefBookChapter").style.display = "none";
          document.getElementById("bibRefParshaSelect").value = initial.bibRefParsha;
        } else {
          document.getElementById("bibRefBookChapter").style.display = "none";
          document.getElementById("bibRefParsha").style.display = "none";
        }
      }
      if (initial.states) {
        const stateCheckboxesDesktop = document.querySelectorAll("#us-states-filter input[type=checkbox]");
        stateCheckboxesDesktop.forEach(cb => { cb.checked = initial.states.includes(cb.value.toLowerCase()); });
        const stateCheckboxesMobile = document.querySelectorAll("#us-states-filter-mobile input[type=checkbox]");
        stateCheckboxesMobile.forEach(cb => { cb.checked = initial.states.includes(cb.value.toLowerCase()); });
      }
      updateMarkersVisibility();
    }

    /*************************************
     * CSV LOADING FUNCTIONS
     *************************************/
    function loadUsUkCities() {
      if (usUkLoaded) return;
      console.log("Loading US–UK Cities...");
      Papa.parse("cities_with_both_coords.csv", {
        download: true,
        header: true,
        dynamicTyping: true,
        complete: function(results) {
          console.log("Loaded cities_with_both_coords.csv, rows:", results.data.length);
          results.data.forEach(function(row) {
            const cityName = row["City"] ? row["City"].trim() : "";
            if (!cityName) return;
            const displayLabel = titleCase(cityName);
            const groupKey = getBaseGroup(cityName);
            const country = (row["Country"] || "").toUpperCase();
            const state = row["State"] ? titleCase(row["State"].trim()) : "";
            if (country === "US" && state && state !== "N/A") {
              usStatesSet.add(state.toLowerCase());
            }
            const lat = parseFloat(row["latitude"]);
            const lng = parseFloat(row["longitude"]);
            const label = displayLabel + (state ? " (" + state + ")" : "");
            const iconToUse = (country === "US") ? iconCityUS : iconCityUK;
            const marker = L.marker([lat, lng], { icon: iconToUse });
            marker.myData = { 
              type: "city", 
              label: label, 
              displayLabel: displayLabel, 
              country: country, 
              state: state, 
              lat: lat, 
              lng: lng, 
              groupKey: groupKey, 
              frozen: false 
            };
            marker.on('click', function() {
              if (!this.isPopupOpen()) { showCityPopup(this); }
            });
            usUkMarkers.push(marker);
          });
          usUkLoaded = true;
          console.log("US–UK markers loaded:", usUkMarkers.length);
          buildFilterPanel();
          updateMarkersVisibility();
        },
        error: function(err) { console.error("Error loading cities_with_both_coords.csv:", err); }
      });
    }
    
    function loadUsBiblicalCities() {
      if (usBiblicalLoaded) return;
      console.log("Loading US Biblical Cities...");
      Papa.parse("processed_biblical_places_sorted.csv", {
        download: true,
        header: true,
        complete: function(results) {
          console.log("Loaded processed_biblical_places_sorted.csv, rows:", results.data.length);
          results.data.forEach(function(row) {
            const placeName = row["Place Name"] ? row["Place Name"].trim() : "";
            if (!placeName) return;
            const displayLabel = titleCase(placeName);
            const groupKey = getBaseGroup(placeName);
            if (!biblicalDataMap[groupKey]) {
              const coordsStr = row["Coordinates"] ? row["Coordinates"].trim() : "";
              const parsedCoords = parseCoordinates(coordsStr, true);
              if (parsedCoords.length > 0) {
                const point = (parsedCoords.length >= 3)
                  ? (function() {
                      const sum = parsedCoords.reduce((acc, pair) => [acc[0] + pair[0], acc[1] + pair[1]], [0, 0]);
                      return [sum[0] / parsedCoords.length, sum[1] / parsedCoords.length];
                    })()
                  : parsedCoords[0];
                const biblicalReferences = row["Sorted Biblical References"] ? row["Sorted Biblical References"].trim() : "";
                const testament = row["Testament"] ? row["Testament"].trim() : "Both";
                biblicalDataMap[groupKey] = { 
                  lat: point[0], 
                  lng: point[1], 
                  polygon: (parsedCoords.length >= 3 ? parsedCoords : null), 
                  biblicalReferences: biblicalReferences,
                  testament: testament
                };
                console.log("Stored biblical data for group:", groupKey, biblicalDataMap[groupKey]);
              }
            }
            const usMatchesRaw = row["US Matching Cities"] ? row["US Matching Cities"].trim() : "";
            const usMatches = usMatchesRaw.split(";").map(s => s.trim()).filter(s => s);
            usMatches.forEach(function(matchStr) {
              const parts = matchStr.split(":");
              if (parts.length < 2) return;
              const matchLabel = parts[0].trim();
              const stateMatch = matchLabel.match(/\(([^)]+)\)/);
              const state = stateMatch ? titleCase(stateMatch[1].trim()) : "";
              if (!state || state.toUpperCase() === "N/A") {
                console.log("Skipping US Biblical marker for label due to missing state:", matchLabel);
                return;
              }
              usStatesSet.add(state.toLowerCase());
              const coordPart = parts[1].trim();
              const latlngArr = coordPart.split(",");
              if (latlngArr.length < 2) return;
              const lat = parseFloat(latlngArr[0]);
              const lng = parseFloat(latlngArr[1]);
              const displayMatchLabel = titleCase(matchLabel);
              const marker = L.marker([lat, lng], { icon: iconUSBiblical });
              const biblicalReferences = row["Sorted Biblical References"] ? row["Sorted Biblical References"].trim() : "";
              const testament = row["Testament"] ? row["Testament"].trim() : "Both";
              marker.myData = { 
                type: "usBiblical", 
                label: displayMatchLabel, 
                state: state, 
                lat: lat, 
                lng: lng, 
                groupKey: groupKey, 
                biblicalReferences: biblicalReferences,
                testament: testament,
                frozen: false 
              };
              marker.on('click', function() {
                if (!this.isPopupOpen()) { showBiblicalPopup(this); }
              });
              marker.on('popupclose', function() {
                console.log("Popup closed for biblical marker:", this.myData.label);
                this.myData.frozen = false;
              });
              usBiblicalMarkers.push(marker);
            });
          });
          usBiblicalLoaded = true;
          console.log("US Biblical markers loaded:", usBiblicalMarkers.length);
          buildFilterPanel();
          updateMarkersVisibility();
        },
        error: function(err) { console.error("Error loading processed_biblical_places_sorted.csv:", err); }
      });
    }

    /*************************************
     * POPUP BUILDERS
     *************************************/
    function showCityPopup(marker) {
      if (marker.isPopupOpen()) return;
      const d = marker.myData;
      const stateDisplay = (d.country === "US" && d.state && d.state.toUpperCase() !== "N/A") ? d.state : "";
      let content = `<strong>${d.displayLabel}</strong><br>`;
      if (stateDisplay) { content += `State: ${stateDisplay}<br>`; }
      content += `Country: ${d.country}<br>`;
      const similar = usUkMarkers.filter(m => m.myData.groupKey.indexOf(d.groupKey) !== -1);
      if (similar.length > 0) {
        content += "<u>Matching Cities:</u><br>";
        const seen = new Set();
        similar.forEach(m => {
          const dd = m.myData;
          const key = dd.displayLabel.trim().toLowerCase() + "|" + dd.country.trim().toLowerCase();
          if (seen.has(key)) return;
          seen.add(key);
          const btnText = (dd.country === "US" && dd.state)
            ? `Fly to ${dd.state}`
            : (dd.country === "UK")
              ? `Fly to ${dd.displayLabel}, ${dd.country}`
              : `Fly to City (${dd.country})`;
          content += `${dd.displayLabel} (${dd.country})<br>`;
          content += `<button class="btn btn-sm btn-secondary mt-1" onclick='flyToLocation(${dd.lat}, ${dd.lng}, "${dd.displayLabel.replace(/"/g, '\\\"')}", "City-${dd.country}")'>${btnText}</button><br>`;
        });
      }
      marker.off('click');
      marker.bindPopup(content, popupOptions).openPopup();
    }
    
    function showBiblicalPopup(marker) {
      if (marker.isPopupOpen()) return;
      const d = marker.myData;
      let content = `<strong>${d.label}</strong><br>`;
      content += buildBiblicalPopupContent(d.biblicalReferences);
      const similar = usBiblicalMarkers.filter(m => m.myData.groupKey === d.groupKey && m.myData.state && m.myData.state.toUpperCase() !== "N/A");
      if (similar.length > 0) {
        content += "<div><u>US Matching Cities:</u><br>";
        const seen = new Set();
        similar.forEach(m => {
          const dd = m.myData;
          const key = dd.label.trim().toLowerCase() + "|" + dd.state.trim().toLowerCase();
          if (seen.has(key)) return;
          seen.add(key);
          content += `${dd.label} (State: ${dd.state})<br>`;
          content += `<button class="btn btn-sm btn-primary mt-1" onclick='flyToLocation(${dd.lat}, ${dd.lng}, "${dd.label.replace(/"/g, '\\\"')}", "US Biblical")'>Fly to US Biblical</button><br>`;
        });
        content += "</div>";
      }
      content += `<br><button class="btn btn-sm btn-success" onclick='flyToBiblicalPlace("${d.groupKey}")'>Fly to Biblical Place</button>`;
      marker.off('click');
      marker.bindPopup(content, popupOptions).openPopup();
    }

    /*************************************
     * FLY-TO FUNCTIONS
     *************************************/
    function flyToLocation(lat, lng, name, type) {
      const groupKey = getBaseGroup(name);
      let foundMarker = null;
      if (type.startsWith("City-")) {
        const desiredCountry = type.split("-")[1];
        foundMarker = usUkMarkers.find(m => m.myData.groupKey === groupKey && m.myData.country === desiredCountry);
        if (!foundMarker) {
          foundMarker = usUkMarkers.find(m => m.myData.groupKey.indexOf(groupKey) !== -1);
        }
      } else if (type === "US Biblical") {
        foundMarker = usBiblicalMarkers.find(m => m.myData.groupKey === groupKey);
      }
      if (foundMarker) {
        console.log("Fly-to found marker:", foundMarker.myData.label);
        foundMarker.myData.frozen = true;
        const orig = foundMarker.options.icon;
        foundMarker.setIcon(highlightIcon);
        map.flyTo(foundMarker.getLatLng(), 10, { duration: 1.5 });
        setTimeout(() => {
          if (!foundMarker.isPopupOpen()) {
            if (foundMarker.myData.type === 'city') { showCityPopup(foundMarker); }
            else { showBiblicalPopup(foundMarker); }
            console.log("Fly-to popup opened for:", foundMarker.myData.label);
          }
          foundMarker.setIcon(orig);
          foundMarker.myData.frozen = false;
          updateMarkersVisibility();
        }, 2000);
      } else {
        console.log("No marker found for fly-to, creating temporary marker for:", name);
        const tempIcon = (type.startsWith("City-"))
          ? ((type.split("-")[1].trim().toLowerCase() === "uk") ? iconCityUK : iconCityUS)
          : (type === "US Biblical" ? iconUSBiblical : iconBiblical);
        const tempMarker = L.marker([lat, lng], { icon: highlightIcon }).addTo(map);
        tempMarker.myData = { type: type, label: name, lat: lat, lng: lng, groupKey: groupKey };
        map.flyTo([lat, lng], 10, { duration: 1.5 });
        setTimeout(() => {
          tempMarker.openPopup();
          console.log("Temporary marker popup opened for:", name);
          map.removeLayer(tempMarker);
        }, 2000);
      }
      console.log("Flying to " + name + " (" + type + ") with groupKey: " + groupKey + " at " + lat + ", " + lng);
    }
    window.flyToLocation = flyToLocation;
    
    function flyToBiblicalPlace(groupKey) {
      const bib = biblicalDataMap[groupKey];
      if (bib) {
        let existing = usBiblicalMarkers.find(m => m.myData.groupKey === groupKey && m.myData.type === "Biblical");
        if (!existing) {
          const marker = L.marker([bib.lat, bib.lng], { icon: iconBiblical }).addTo(map);
          const biblicalRefs = bib.biblicalReferences || "";
          marker.myData = { type: "Biblical", label: titleCase(groupKey), biblicalReferences: biblicalRefs, lat: bib.lat, lng: bib.lng, groupKey: groupKey, frozen: true };
          marker.on('click', function() { showBiblicalPopup(this); });
          marker.on('popupclose', function() {
            console.log("Biblical popup closed for:", this.myData.label);
            this.myData.frozen = false;
            updateMarkersVisibility();
          });
          usBiblicalMarkers.push(marker);
          existing = marker;
          console.log("Created new biblical marker for group:", groupKey);
        }
        if (bib.polygon) {
          const poly = L.polygon(bib.polygon, { color: "green", weight: 3 }).addTo(map);
          setTimeout(() => { map.removeLayer(poly); }, 2000);
        }
        map.flyTo([bib.lat, bib.lng], 10, { duration: 1.5 });
        setTimeout(() => { existing.openPopup(); console.log("Biblical fly-to popup opened for:", existing.myData.label); }, 2000);
      } else {
        alert("Biblical place data not found for group: " + groupKey);
      }
    }
    window.flyToBiblicalPlace = flyToBiblicalPlace;

    /*************************************
     * MARKER FILTERING & BUILDING
     *************************************/
    function updateMarkersVisibility() {
      const filters = getFilterSettings();
      if (filters.toggleUSUK && !usUkLoaded) { loadUsUkCities(); }
      if (filters.toggleUSBiblical && !usBiblicalLoaded) { loadUsBiblicalCities(); }
      
      usUkLayerGroup.clearLayers();
      oldBiblicalLayerGroup.clearLayers();
      newBiblicalLayerGroup.clearLayers();
      bothBiblicalLayerGroup.clearLayers();
      
      if (filters.toggleUSUK) {
        usUkMarkers.forEach(m => {
          const d = m.myData;
          if (d.country === "US" && filters.selectedStates && filters.selectedStates.length > 0 && d.state && filters.selectedStates.indexOf(d.state.toLowerCase()) === -1) {
            return;
          }
          usUkLayerGroup.addLayer(m);
        });
      }
      
      if (filters.toggleUSBiblical) {
        usBiblicalMarkers.forEach(m => {
          const d = m.myData;
          if (d.state && filters.selectedStates && filters.selectedStates.length > 0 && filters.selectedStates.indexOf(d.state.toLowerCase()) === -1) return;
          const markerTestament = normalizeTestament(d.testament || "Both");
          if (filters.testament !== "both" && markerTestament !== filters.testament) return;
          if (!markerPassesBibRefFilter(m)) return;
          if (markerTestament === "old") { oldBiblicalLayerGroup.addLayer(m); }
          else if (markerTestament === "new") { newBiblicalLayerGroup.addLayer(m); }
          else { bothBiblicalLayerGroup.addLayer(m); }
        });
      }
      
      if (filters.toggleUSUK) { usUkLayerGroup.addTo(map); } else { map.removeLayer(usUkLayerGroup); }
      if (filters.toggleUSBiblical) {
        oldBiblicalLayerGroup.addTo(map);
        newBiblicalLayerGroup.addTo(map);
        bothBiblicalLayerGroup.addTo(map);
      } else {
        map.removeLayer(oldBiblicalLayerGroup);
        map.removeLayer(newBiblicalLayerGroup);
        map.removeLayer(bothBiblicalLayerGroup);
      }
    }

    /*************************************
     * BUILD FILTER PANEL (States)
     *************************************/
    function buildFilterPanel() {
      const initialFilters = getInitialFiltersFromUrl();
      const container = document.getElementById("us-states-filter");
      container.innerHTML = "";
      const states = Array.from(usStatesSet).sort();
      console.log("Building desktop filter panel with states:", states);
      states.forEach(state => {
        const checkboxId = "state-" + state.replace(/\s+/g, "_");
        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.id = checkboxId;
        checkbox.value = state;
        checkbox.checked = initialFilters.states ? initialFilters.states.includes(state.toLowerCase()) : true;
        checkbox.addEventListener("change", () => { updateUrlWithFilters(); updateMarkersVisibility(); });
        container.appendChild(checkbox);
        const label = document.createElement("label");
        label.htmlFor = checkboxId;
        label.innerText = " " + titleCase(state);
        container.appendChild(label);
        const onlyBtn = document.createElement("button");
        onlyBtn.type = "button";
        onlyBtn.className = "btn btn-sm btn-link ms-1";
        onlyBtn.innerText = "Only";
        onlyBtn.addEventListener("click", function() {
          container.querySelectorAll("input[type=checkbox]").forEach(inp => { inp.checked = false; });
          checkbox.checked = true;
          updateUrlWithFilters();
          updateMarkersVisibility();
        });
        container.appendChild(onlyBtn);
        container.appendChild(document.createElement("br"));
      });
      document.getElementById("selectAllStates").addEventListener("click", function() {
        container.querySelectorAll("input[type=checkbox]").forEach(inp => { inp.checked = true; });
        updateUrlWithFilters();
        updateMarkersVisibility();
      });
      const mobileContainer = document.getElementById("us-states-filter-mobile");
      if (mobileContainer) {
        mobileContainer.innerHTML = container.innerHTML;
        mobileContainer.querySelectorAll("input[type=checkbox]").forEach(checkbox => {
          checkbox.addEventListener("change", () => { updateUrlWithFilters(); updateMarkersVisibility(); });
        });
        document.getElementById("selectAllStates_mobile").addEventListener("click", function() {
          mobileContainer.querySelectorAll("input[type=checkbox]").forEach(inp => { inp.checked = true; });
          updateUrlWithFilters();
          updateMarkersVisibility();
        });
      }
    }

    /*************************************
     * SET UP CITY SEARCH
     *************************************/
    function setupCitySearch() {
      const searchInput = document.getElementById("citySearch");
      const resultsList = document.getElementById("searchResults");
      searchInput.addEventListener("input", function() {
        const query = this.value.toLowerCase().trim();
        resultsList.innerHTML = "";
        if (!query) { resultsList.style.display = "none"; return; }
        const matches = new Set();
        usUkMarkers.forEach(m => {
          if (m.myData.groupKey.indexOf(query) !== -1 || m.myData.label.toLowerCase().indexOf(query) !== -1) {
            matches.add(m.myData.groupKey);
          }
        });
        usBiblicalMarkers.forEach(m => {
          if (m.myData.groupKey.indexOf(query) !== -1 || m.myData.label.toLowerCase().indexOf(query) !== -1) {
            matches.add(m.myData.groupKey);
          }
        });
        const matchArr = Array.from(matches);
        if (matchArr.length > 0) {
          matchArr.slice(0, 20).forEach(match => {
            const li = document.createElement("li");
            li.innerText = titleCase(match);
            li.onclick = function() {
              const marker = usBiblicalMarkers.find(m => m.myData.groupKey === match) ||
                             usUkMarkers.find(m => m.myData.groupKey === match);
              if (marker) {
                map.flyTo(marker.getLatLng(), 10, { duration: 1.5 });
                marker.openPopup();
              }
              resultsList.style.display = "none";
              searchInput.value = "";
            };
            resultsList.appendChild(li);
          });
          resultsList.style.display = "block";
        } else {
          resultsList.style.display = "none";
        }
      });
      
      const searchInputMobile = document.getElementById("citySearch_mobile");
      const resultsListMobile = document.getElementById("searchResults_mobile");
      if (searchInputMobile) {
        searchInputMobile.addEventListener("input", function() {
          const query = this.value.toLowerCase().trim();
          resultsListMobile.innerHTML = "";
          if (!query) { resultsListMobile.style.display = "none"; return; }
          const matches = new Set();
          usUkMarkers.forEach(m => {
            if (m.myData.groupKey.indexOf(query) !== -1 || m.myData.label.toLowerCase().indexOf(query) !== -1) {
              matches.add(m.myData.groupKey);
            }
          });
          usBiblicalMarkers.forEach(m => {
            if (m.myData.groupKey.indexOf(query) !== -1 || m.myData.label.toLowerCase().indexOf(query) !== -1) {
              matches.add(m.myData.groupKey);
            }
          });
          const matchArr = Array.from(matches);
          if (matchArr.length > 0) {
            matchArr.slice(0, 20).forEach(match => {
              const li = document.createElement("li");
              li.innerText = titleCase(match);
              li.onclick = function() {
                const marker = usBiblicalMarkers.find(m => m.myData.groupKey === match) ||
                               usUkMarkers.find(m => m.myData.groupKey === match);
                if (marker) {
                  map.flyTo(marker.getLatLng(), 10, { duration: 1.5 });
                  marker.openPopup();
                }
                resultsListMobile.style.display = "none";
                searchInputMobile.value = "";
              };
              resultsListMobile.appendChild(li);
            });
            resultsListMobile.style.display = "block";
          } else {
            resultsListMobile.style.display = "none";
          }
        });
      }
    }

    function zoomToAllMarkers() {
      const bounds = L.latLngBounds([]);
      usUkMarkers.forEach(m => { if (map.hasLayer(m)) bounds.extend(m.getLatLng()); });
      usBiblicalMarkers.forEach(m => { if (map.hasLayer(m)) bounds.extend(m.getLatLng()); });
      if (bounds.isValid()) { map.fitBounds(bounds); }
      else { console.log("No markers in bounds to zoom to."); }
    }
    document.getElementById("zoomAllBtn").addEventListener("click", zoomToAllMarkers);
    if (document.getElementById("zoomAllBtn_mobile")) {
      document.getElementById("zoomAllBtn_mobile").addEventListener("click", zoomToAllMarkers);
    }

    /*************************************
     * EVENT LISTENERS FOR FILTER CONTROLS
     *************************************/
    document.getElementById("toggleUSUK").addEventListener("change", () => { updateMarkersVisibility(); updateUrlWithFilters(); });
    document.getElementById("toggleUSBiblical").addEventListener("change", () => { updateMarkersVisibility(); updateUrlWithFilters(); });
    if (document.getElementById("toggleUSUK_mobile")) {
      document.getElementById("toggleUSUK_mobile").addEventListener("change", () => { updateMarkersVisibility(); updateUrlWithFilters(); });
    }
    if (document.getElementById("toggleUSBiblical_mobile")) {
      document.getElementById("toggleUSBiblical_mobile").addEventListener("change", () => { updateMarkersVisibility(); updateUrlWithFilters(); });
    }
    document.getElementById("testamentFilter").addEventListener("change", () => { updateMarkersVisibility(); updateUrlWithFilters(); });
    if (document.getElementById("testamentFilter_mobile")) {
      document.getElementById("testamentFilter_mobile").addEventListener("change", () => { updateMarkersVisibility(); updateUrlWithFilters(); });
    }
    // Add listeners for the biblical reference dropdowns and input fields (desktop)
    document.getElementById("bibRefFilterType").addEventListener("change", function() {
      const value = this.value.toLowerCase();
      if (value === "book") {
        document.getElementById("bibRefBookChapter").style.display = "block";
        document.getElementById("bibRefParsha").style.display = "none";
      } else if (value === "parsha") {
        document.getElementById("bibRefBookChapter").style.display = "none";
        document.getElementById("bibRefParsha").style.display = "block";
      } else {
        document.getElementById("bibRefBookChapter").style.display = "none";
        document.getElementById("bibRefParsha").style.display = "none";
      }
      updateUrlWithFilters();
      updateMarkersVisibility();
    });
    document.getElementById("bibRefBook").addEventListener("change", function() {
      updateUrlWithFilters();
      updateMarkersVisibility();
    });
    document.getElementById("bibRefChapter").addEventListener("input", function() {
      updateUrlWithFilters();
      updateMarkersVisibility();
    });
    document.getElementById("bibRefParshaSelect").addEventListener("change", function() {
      updateUrlWithFilters();
      updateMarkersVisibility();
    });
    // And similarly for mobile:
    if (document.getElementById("bibRefFilterType_mobile")) {
      document.getElementById("bibRefFilterType_mobile").addEventListener("change", function() {
        const value = this.value.toLowerCase();
        if (value === "book") {
          document.getElementById("bibRefBookChapter_mobile").style.display = "block";
          document.getElementById("bibRefParsha_mobile").style.display = "none";
        } else if (value === "parsha") {
          document.getElementById("bibRefBookChapter_mobile").style.display = "none";
          document.getElementById("bibRefParsha_mobile").style.display = "block";
        } else {
          document.getElementById("bibRefBookChapter_mobile").style.display = "none";
          document.getElementById("bibRefParsha_mobile").style.display = "none";
        }
        updateUrlWithFilters();
        updateMarkersVisibility();
      });
      document.getElementById("bibRefBook_mobile").addEventListener("change", function() {
        updateUrlWithFilters();
        updateMarkersVisibility();
      });
      document.getElementById("bibRefChapter_mobile").addEventListener("input", function() {
        updateUrlWithFilters();
        updateMarkersVisibility();
      });
      document.getElementById("bibRefParshaSelect_mobile").addEventListener("change", function() {
        updateUrlWithFilters();
        updateMarkersVisibility();
      });
    }

    /*************************************
     * EXTERNAL JSON: Load biblical books and parsha data
     *************************************/
    function populateBibRefBookDropdown() {
      const select = document.getElementById("bibRefBook");
      const selectMobile = document.getElementById("bibRefBook_mobile");
      if (!select || !selectMobile) return;
      select.innerHTML = "";
      selectMobile.innerHTML = "";
      Object.keys(booksData).forEach(bookName => {
        const option = document.createElement("option");
        option.value = bookName;
        option.textContent = bookName;
        select.appendChild(option);
        const optionMobile = document.createElement("option");
        optionMobile.value = bookName;
        optionMobile.textContent = bookName;
        selectMobile.appendChild(optionMobile);
      });
    }
    function populateParshaDropdown() {
      const select = document.getElementById("bibRefParshaSelect");
      const selectMobile = document.getElementById("bibRefParshaSelect_mobile");
      if (!select || !selectMobile) return;
      select.innerHTML = "";
      selectMobile.innerHTML = "";
      Object.keys(parshaDataLoaded).forEach(parsha => {
        const option = document.createElement("option");
        option.value = parsha;
        option.textContent = parsha;
        select.appendChild(option);
        const optionMobile = document.createElement("option");
        optionMobile.value = parsha;
        optionMobile.textContent = parsha;
        selectMobile.appendChild(optionMobile);
      });
    }
    fetch('books_parshas.json')
      .then(response => response.json())
      .then(data => {
        booksData = data.books;
        parshaDataLoaded = data.parshaData;
        populateBibRefBookDropdown();
        populateParshaDropdown();
      })
      .catch(error => console.error('Error loading books_parshas.json:', error));

    /*************************************
     * INITIAL UI SETUP
     *************************************/
    buildFilterPanel();
    setupCitySearch();
    document.addEventListener("DOMContentLoaded", applyFiltersFromUrl);
  })();
  </script>

  <!-- Optional Sefaria Linker Script -->
  <script type="text/javascript" charset="utf-8" src="https://www.sefaria.org/linker.v3.js"></script>
  <script>
    sefaria.link({ mode: "popup-click", dynamic: true });
  </script>
</body>
</html>
