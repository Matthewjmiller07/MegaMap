<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Combined Biblical & US/UK Cities Map</title>
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.3/dist/leaflet.css" />
  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css" />
  <!-- Leaflet Awesome Markers CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Leaflet.awesome-markers/2.0.2/leaflet.awesome-markers.css" />
  <style>
    html, body { margin: 0; padding: 0; height: 100%; }
    #map { width: 100%; height: 100%; }
    /* Filter panel styling */
    #filter-panel {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 1100;
      background: white;
      padding: 10px;
      border: 1px solid #ccc;
      max-height: 90%;
      overflow-y: auto;
      font-size: 0.9rem;
      width: 280px;
    }
    /* Search results styling */
    #searchResults {
      max-height: 150px;
      overflow-y: auto;
      border: 1px solid #ddd;
      border-radius: 4px;
      display: none;
      margin-top: 5px;
      padding-left: 0;
    }
    #searchResults li { list-style: none; padding: 5px; cursor: pointer; }
    #searchResults li:hover { background-color: #f0f0f0; }
  </style>
</head>
<body>
  <!-- Map container -->
  <div id="map"></div>
  
  <!-- Filter Panel – by default no markers are loaded -->
  <div id="filter-panel">
    <h5>Filter Markers</h5>
    <!-- Two toggles for lazy loading marker sets -->
    <div class="mb-2">
      <input type="checkbox" id="toggleUSUK">
      <label for="toggleUSUK">Show US‑UK Cities</label>
    </div>
    <div class="mb-2">
      <input type="checkbox" id="toggleUSBiblical">
      <label for="toggleUSBiblical">Show US Biblical Cities</label>
    </div>
    <!-- State filter panel -->
    <div class="mb-2">
      <strong>US States:</strong>
      <div id="us-states-filter"></div>
      <button id="selectAllStates" class="btn btn-sm btn-primary mt-2">Select All States</button>
    </div>
    <!-- Zoom All Button -->
    <div class="mt-2">
      <button id="zoomAllBtn" class="btn btn-sm btn-warning">Zoom to All Markers</button>
    </div>
    <!-- Search Box -->
    <div class="mt-3">
      <label for="citySearch" class="form-label">Search (by group):</label>
      <input type="text" id="citySearch" class="form-control form-control-sm" placeholder="Type to search...">
      <ul id="searchResults"></ul>
    </div>
  </div>
  
  <!-- Scripts -->
  <!-- jQuery -->
  <script src="https://code.jquery.com/jquery-1.12.4.min.js"></script>
  <!-- Bootstrap Bundle JS -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/js/bootstrap.bundle.min.js"></script>
  <!-- PapaParse -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
  <!-- Leaflet JS -->
  <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.3/dist/leaflet.js"></script>
  <!-- Leaflet Awesome Markers JS -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Leaflet.awesome-markers/2.0.2/leaflet.awesome-markers.js"></script>
  
  <script>
    /***********************
     * UTILITY FUNCTIONS
     ***********************/
    // cleanPlaceName: returns the part before "/" with any trailing digits removed.
    function cleanPlaceName(name) {
      let cleaned = name.split("/")[0].trim();
      return cleaned.replace(/\s*\d+$/, "");
    }
    // getBaseGroup: returns a lower-case key by removing trailing digits, any parenthetical text, and the word "beach".
    function getBaseGroup(name) {
      if (!name) return "";
      let cleaned = name.split("/")[0].trim().toLowerCase();
      cleaned = cleaned.replace(/\s*\d+$/, "");
      cleaned = cleaned.replace(/\(.*\)/, "").trim();
      cleaned = cleaned.replace(/\bbeach\b/g, "").trim();
      return cleaned;
    }
    // parseCoordinates: splits a coordinate string into an array of [lat, lon] pairs.
    // For processed_biblical_places.csv, coordinates are stored as long,lat so pass swap=true.
    function parseCoordinates(coordStr, swap = false) {
      coordStr = coordStr.trim();
      if (!coordStr) return [];
      let pairs = coordStr.split(" ").filter(s => s.trim() !== "");
      return pairs.map(pair => {
        let coords = pair.split(",");
        if (swap) {
          return [parseFloat(coords[1]), parseFloat(coords[0])];
        } else {
          return [parseFloat(coords[0]), parseFloat(coords[1])];
        }
      });
    }
    function parseFirstCoordinate(coordStr, swap = false) {
      let arr = parseCoordinates(coordStr, swap);
      return (arr.length > 0) ? arr[0] : [0, 0];
    }
    
    /***********************
     * GLOBAL VARIABLES
     ***********************/
    // Marker arrays (loaded lazily)
    let usUkMarkers = [];      // from cities_with_both_coords.csv
    let usBiblicalMarkers = []; // from processed_biblical_places.csv
    let usUkLoaded = false;
    let usBiblicalLoaded = false;
    
    // biblicalDataMap: keyed by groupKey, stores an object { lat, lng, polygon } from processed_biblical_places.csv.
    let biblicalDataMap = {};
    
    // For state filtering
    let usStatesSet = new Set();
    
    // Settings
    let advancedBiblical = false; // (toggle for showing only “Most Likely” biblical entries, if desired)
    
    /***********************
     * ICON DEFINITIONS
     ***********************/
    let iconCityUS = L.AwesomeMarkers.icon({ icon: 'info-sign', markerColor: 'blue', prefix: 'glyphicon' });
    let iconCityUK = L.AwesomeMarkers.icon({ icon: 'info-sign', markerColor: 'red', prefix: 'glyphicon' });
    let iconUSBiblical = L.AwesomeMarkers.icon({ icon: 'info-sign', markerColor: 'purple', prefix: 'glyphicon' });
    // iconBiblical is used when flying to the biblical place.
    let iconBiblical = L.AwesomeMarkers.icon({ icon: 'info-sign', markerColor: 'green', prefix: 'glyphicon' });
    let highlightIcon = L.AwesomeMarkers.icon({ icon: 'star', markerColor: 'orange', prefix: 'glyphicon' });
    
    /***********************
     * INITIALIZE MAP
     ***********************/
    let map = L.map('map').setView([39.50, -98.35], 4);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; OpenStreetMap contributors',
      maxZoom: 18
    }).addTo(map);
    
    /*****************************************************
     * LAZY CSV LOADING FUNCTIONS
     *****************************************************/
    // Load US–UK Cities from cities_with_both_coords.csv.
    function loadUsUkCities() {
      if (usUkLoaded) return;
      console.log("Loading US–UK Cities...");
      Papa.parse("cities_with_both_coords.csv", {
        download: true,
        header: true,
        dynamicTyping: true,
        complete: function(results) {
          console.log("Loaded cities_with_both_coords.csv, rows:", results.data.length);
          results.data.forEach(function(row) {
            let cityName = row["City"] ? row["City"].trim() : "";
            if (!cityName) return;
            let groupKey = getBaseGroup(cityName);
            let country = (row["Country"] || "").toUpperCase();
            let state = row["State"] ? row["State"].trim() : "";
            // For US rows, add state to the set. (UK rows may have blank state.)
            if (country === "US" && state) { 
              usStatesSet.add(state.toLowerCase());
            }
            let lat = parseFloat(row["latitude"]);
            let lng = parseFloat(row["longitude"]);
            let label = cityName + (state ? " (" + state + ")" : "");
            let iconToUse = (country === "US") ? iconCityUS : iconCityUK;
            let marker = L.marker([lat, lng], { icon: iconToUse });
            // Save all data along with groupKey.
            marker.myData = { type: "city", label: label, country: country, state: state, lat: lat, lng: lng, groupKey: groupKey, frozen: false };
            marker.on('click', function() { showCityPopup(this); });
            usUkMarkers.push(marker);
          });
          usUkLoaded = true;
          console.log("US–UK markers loaded:", usUkMarkers.length);
          buildFilterPanel();
          updateMarkersVisibility();
        },
        error: function(err) { console.error("Error loading cities_with_both_coords.csv:", err); }
      });
    }
    
    // Load US Biblical Cities from processed_biblical_places.csv.
    function loadUsBiblicalCities() {
      if (usBiblicalLoaded) return;
      console.log("Loading US Biblical Cities...");
      Papa.parse("processed_biblical_places.csv", {
        download: true,
        header: true,
        complete: function(results) {
          console.log("Loaded processed_biblical_places.csv, rows:", results.data.length);
          results.data.forEach(function(row) {
            let placeName = row["Place Name"] ? row["Place Name"].trim() : "";
            if (!placeName) return;
            let groupKey = getBaseGroup(placeName);
            // Save biblical place data for fly‑to if not already saved.
            if (!biblicalDataMap[groupKey]) {
              let coordsStr = row["Coordinates"] ? row["Coordinates"].trim() : "";
              let parsedCoords = parseCoordinates(coordsStr, true); // Swap because coordinates are stored as long,lat
              if (parsedCoords.length > 0) {
                let point = (parsedCoords.length >= 3)
                  ? (function() {
                      let sum = parsedCoords.reduce((acc, pair) => [acc[0] + pair[0], acc[1] + pair[1]], [0, 0]);
                      return [sum[0] / parsedCoords.length, sum[1] / parsedCoords.length];
                    })()
                  : parsedCoords[0];
                biblicalDataMap[groupKey] = { lat: point[0], lng: point[1], polygon: (parsedCoords.length >= 3 ? parsedCoords : null) };
                console.log("Stored biblical data for group:", groupKey, biblicalDataMap[groupKey]);
              }
            }
            // Process the "US Matching Cities" column.
            let usMatchesRaw = row["US Matching Cities"] ? row["US Matching Cities"].trim() : "";
            let usMatches = usMatchesRaw.split(";").map(s => s.trim()).filter(s => s !== "");
            usMatches.forEach(function(matchStr) {
              // Expected format: "City (State) - placeType: lat,lon"
              let parts = matchStr.split(":");
              if (parts.length < 2) return;
              let label = parts[0].trim();
              // Skip if state is missing or "N/A"
              let stateMatch = label.match(/\(([^)]+)\)/);
              let state = stateMatch ? stateMatch[1].trim() : "";
              if (!state || state.toUpperCase() === "N/A") {
                console.log("Skipping US Biblical marker for label due to missing state:", label);
                return;
              }
              console.log("Extracted state:", state, "for label:", label);
              usStatesSet.add(state.toLowerCase());
              let coordPart = parts[1].trim();
              let latlngArr = coordPart.split(",");
              if (latlngArr.length < 2) return;
              let lat = parseFloat(latlngArr[0]);
              let lng = parseFloat(latlngArr[1]);
              let marker = L.marker([lat, lng], { icon: iconUSBiblical });
              marker.myData = { type: "usBiblical", label: label, state: state, lat: lat, lng: lng, groupKey: groupKey, frozen: false };
              marker.on('click', function() { showBiblicalPopup(this); });
              usBiblicalMarkers.push(marker);
            });
          });
          usBiblicalLoaded = true;
          console.log("US Biblical markers loaded:", usBiblicalMarkers.length);
          buildFilterPanel();
          updateMarkersVisibility();
        },
        error: function(err) { console.error("Error loading processed_biblical_places.csv:", err); }
      });
    }
    
    /*****************************************************
     * POPUP BUILDERS
     *****************************************************/
    // Popup for US/UK City markers.
    function showCityPopup(marker) {
      let d = marker.myData;
      // For US rows, only display the state if it is valid. For UK rows, state may be blank.
      let stateDisplay = (d.country === "US" && d.state && d.state.toUpperCase() !== "N/A") ? d.state : (d.country === "US" ? "" : "");
      let content = "<strong>" + d.label + "</strong><br>";
      if (stateDisplay) { content += "State: " + stateDisplay + "<br>"; }
      content += "Country: " + d.country + "<br>";
      // Find matching markers among US/UK markers whose groupKey contains this marker’s groupKey.
      let similar = usUkMarkers.filter(m => m.myData.groupKey.indexOf(d.groupKey) !== -1);
      if (similar.length > 0) {
        content += "<u>Matching Cities:</u><br>";
        let seen = {};
        similar.forEach(m => {
          let dd = m.myData;
          // For US rows, require a valid state; for UK rows, allow blank.
          if (dd.country === "US" && (!dd.state || dd.state.toUpperCase() === "N/A")) return;
          let key = dd.label + " (" + dd.country + ")";
          if (!seen[key]) {
            seen[key] = true;
            let btnType = "City-" + dd.country;
            content += key + "<br>" +
              "<button class='btn btn-sm btn-secondary mt-1' onclick='flyToLocation(" + dd.lat + ", " + dd.lng + ", \"" + dd.label.replace(/"/g, '\\\"') + "\", \"" + btnType + "\")'>Fly to City (" + dd.country + ")</button><br>";
          }
        });
      }
      console.log("City popup for groupKey:", d.groupKey, "content:", content);
      marker.bindPopup(content).openPopup();
    }
    
    // Popup for US Biblical markers.
    function showBiblicalPopup(marker) {
      let d = marker.myData;
      let content = "<strong>" + d.label + "</strong><br>";
      // List matching US Biblical markers (only those with a valid state)
      let similar = usBiblicalMarkers.filter(m => m.myData.groupKey === d.groupKey && m.myData.state && m.myData.state.toUpperCase() !== "N/A");
      if (similar.length > 0) {
        content += "<u>US Matching Cities:</u><br>";
        let seen = {};
        similar.forEach(m => {
          let dd = m.myData;
          let key = dd.label + " (State: " + dd.state + ")";
          if (!seen[key]) {
            seen[key] = true;
            content += key + "<br>" +
              "<button class='btn btn-sm btn-primary mt-1' onclick='flyToLocation(" + dd.lat + ", " + dd.lng + ", \"" + dd.label.replace(/"/g, '\\\"') + "\", \"US Biblical\")'>Fly to US Biblical</button><br>";
          }
        });
      }
      // In the biblical popup, if this marker is not already a biblical-place marker (type "Biblical"),
      // include a button to fly to the biblical place.
      content += "<br><button class='btn btn-sm btn-success' onclick='flyToBiblicalPlace(\"" + d.groupKey + "\")'>Fly to Biblical Place</button>";
      console.log("Biblical popup for groupKey:", d.groupKey, "content:", content);
      marker.bindPopup(content).openPopup();
    }
    
    // When clicking “Back to US Cities” in a biblical popup.
    function flyToCityView(groupKey) {
      let marker = usUkMarkers.find(m => m.myData.groupKey === groupKey);
      if (marker) {
        map.flyTo(marker.getLatLng(), 10, { duration: 1.5 });
        marker.openPopup();
      } else {
        alert("No US/UK city marker found for group: " + groupKey);
      }
    }
    
    // Fly-to functionality for markers.
    // For city markers, type should be "City-US" or "City-UK"; for biblical markers, use "US Biblical".
    function flyToLocation(lat, lng, name, type) {
      let groupKey = getBaseGroup(name);
      let foundMarker = null;
      if (type.startsWith("City-")) {
        let desiredCountry = type.split("-")[1];
        // Try exact match first
        foundMarker = usUkMarkers.find(m => m.myData.groupKey === groupKey && m.myData.country === desiredCountry);
        // If not found, do a fuzzy search
        if (!foundMarker) {
          foundMarker = usUkMarkers.find(m => m.myData.groupKey.indexOf(groupKey) !== -1);
        }
      } else if (type === "US Biblical") {
        foundMarker = usBiblicalMarkers.find(m => m.myData.groupKey === groupKey);
      }
      if (foundMarker) {
        // If the marker is filtered out, add it (and mark it as frozen so filtering won’t remove it)
        if (!map.hasLayer(foundMarker)) { 
          map.addLayer(foundMarker); 
          foundMarker.myData.frozen = true;
        }
        let orig = foundMarker.options.icon;
        foundMarker.setIcon(highlightIcon);
        setTimeout(() => { foundMarker.setIcon(orig); }, 2000);
        map.flyTo(foundMarker.getLatLng(), 10, { duration: 1.5 });
        foundMarker.openPopup();
      } else {
        // Create a temporary marker if none is found.
        let tempIcon = (type.startsWith("City-"))
          ? ((type.split("-")[1] === "UK") ? iconCityUK : iconCityUS)
          : (type === "US Biblical" ? iconUSBiblical : iconBiblical);
        let tempMarker = L.marker([lat, lng], { icon: highlightIcon }).addTo(map);
        tempMarker.myData = { type: type, label: name, lat: lat, lng: lng, groupKey: groupKey, frozen: true };
        setTimeout(() => { map.removeLayer(tempMarker); }, 2000);
        map.flyTo([lat, lng], 10, { duration: 1.5 });
      }
      console.log("Flying to " + name + " (" + type + ") with groupKey: " + groupKey + " at " + lat + ", " + lng);
    }
    window.flyToLocation = flyToLocation;
    
    // Fly-to a biblical place using biblicalDataMap.
    function flyToBiblicalPlace(groupKey) {
      let bib = biblicalDataMap[groupKey];
      if (bib) {
        // Try to find an existing biblical marker (type "Biblical") for this group.
        let existing = usBiblicalMarkers.find(m => m.myData.groupKey === groupKey && m.myData.type === "Biblical");
        if (!existing) {
          let marker = L.marker([bib.lat, bib.lng], { icon: iconBiblical }).addTo(map);
          marker.myData = { type: "Biblical", label: groupKey, lat: bib.lat, lng: bib.lng, groupKey: groupKey, frozen: true };
          marker.on('click', function() { showBiblicalPopup(this); });
          usBiblicalMarkers.push(marker);
          existing = marker;
          console.log("Created new biblical marker for group:", groupKey);
        }
        if (bib.polygon) {
          let poly = L.polygon(bib.polygon, { color: "green", weight: 3 }).addTo(map);
          setTimeout(() => { map.removeLayer(poly); }, 2000);
        }
        map.flyTo([bib.lat, bib.lng], 10, { duration: 1.5 });
        existing.openPopup();
      } else {
        alert("Biblical place data not found for group: " + groupKey);
      }
    }
    
    /*****************************************************
     * FILTERING & STATE PANEL
     *****************************************************/
    function updateMarkersVisibility() {
      // Lazy load markers if toggles are checked.
      if (document.getElementById("toggleUSUK").checked && !usUkLoaded) {
        loadUsUkCities();
      }
      if (document.getElementById("toggleUSBiblical").checked && !usBiblicalLoaded) {
        loadUsBiblicalCities();
      }
      // Remove markers if toggles are unchecked.
      if (!document.getElementById("toggleUSUK").checked) {
        usUkMarkers.forEach(m => { if (map.hasLayer(m)) map.removeLayer(m); });
      } else {
        usUkMarkers.forEach(m => { if (!map.hasLayer(m)) map.addLayer(m); });
      }
      if (!document.getElementById("toggleUSBiblical").checked) {
        usBiblicalMarkers.forEach(m => { if (map.hasLayer(m)) map.removeLayer(m); });
      } else {
        usBiblicalMarkers.forEach(m => { if (!map.hasLayer(m)) map.addLayer(m); });
      }
      // Filter markers by US state—but do not remove markers that are "frozen"
      let stateInputs = document.querySelectorAll("#us-states-filter input[type=checkbox]");
      let selectedStates = [];
      stateInputs.forEach(cb => { if (cb.checked) selectedStates.push(cb.value.trim().toLowerCase()); });
      usUkMarkers.forEach(m => {
        let d = m.myData;
        if (d.country === "US" && d.state && selectedStates.indexOf(d.state.toLowerCase()) === -1 && !d.frozen) {
          if (map.hasLayer(m)) map.removeLayer(m);
        }
      });
      usBiblicalMarkers.forEach(m => {
        let d = m.myData;
        if (d.state && selectedStates.indexOf(d.state.toLowerCase()) === -1 && !d.frozen) {
          if (map.hasLayer(m)) map.removeLayer(m);
        }
      });
    }
    
    function buildFilterPanel() {
      let container = document.getElementById("us-states-filter");
      container.innerHTML = "";
      let states = Array.from(usStatesSet).sort();
      console.log("Building filter panel with states:", states);
      states.forEach(state => {
        let checkboxId = "state-" + state.replace(/\s+/g, "_");
        let checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.id = checkboxId;
        checkbox.value = state;
        checkbox.checked = true;
        checkbox.onchange = updateMarkersVisibility;
        container.appendChild(checkbox);
        let label = document.createElement("label");
        label.htmlFor = checkboxId;
        label.innerText = " " + state;
        container.appendChild(label);
        let onlyBtn = document.createElement("button");
        onlyBtn.type = "button";
        onlyBtn.className = "btn btn-sm btn-link ms-1";
        onlyBtn.innerText = "Only";
        onlyBtn.onclick = function() {
          let inputs = container.querySelectorAll("input[type=checkbox]");
          inputs.forEach(inp => { inp.checked = false; });
          checkbox.checked = true;
          updateMarkersVisibility();
        };
        container.appendChild(onlyBtn);
        container.appendChild(document.createElement("br"));
      });
      // “Select All States” button: check all boxes.
      document.getElementById("selectAllStates").onclick = function() {
        let inputs = container.querySelectorAll("input[type=checkbox]");
        inputs.forEach(inp => { inp.checked = true; });
        updateMarkersVisibility();
      };
    }
    
    function setupCitySearch() {
      let searchInput = document.getElementById("citySearch");
      let resultsList = document.getElementById("searchResults");
      searchInput.addEventListener("input", function() {
        let query = this.value.toLowerCase().trim();
        resultsList.innerHTML = "";
        if (!query) { resultsList.style.display = "none"; return; }
        let matches = new Set();
        // Search among both marker sets using groupKey or part of the label.
        usUkMarkers.forEach(m => {
          if (m.myData.groupKey.indexOf(query) !== -1 || m.myData.label.toLowerCase().indexOf(query) !== -1) {
            matches.add(m.myData.groupKey);
          }
        });
        usBiblicalMarkers.forEach(m => {
          if (m.myData.groupKey.indexOf(query) !== -1 || m.myData.label.toLowerCase().indexOf(query) !== -1) {
            matches.add(m.myData.groupKey);
          }
        });
        matches = Array.from(matches);
        if (matches.length > 0) {
          matches.slice(0, 20).forEach(match => {
            let li = document.createElement("li");
            li.innerText = match;
            li.onclick = function() {
              let marker = usBiblicalMarkers.find(m => m.myData.groupKey === match) ||
                           usUkMarkers.find(m => m.myData.groupKey === match);
              if (marker) {
                map.flyTo(marker.getLatLng(), 10, { duration: 1.5 });
                marker.openPopup();
              }
              resultsList.style.display = "none";
              searchInput.value = "";
            };
            resultsList.appendChild(li);
          });
          resultsList.style.display = "block";
        } else {
          resultsList.style.display = "none";
        }
      });
    }
    
    function zoomToAllMarkers() {
      let bounds = L.latLngBounds([]);
      usUkMarkers.forEach(m => { if (map.hasLayer(m)) bounds.extend(m.getLatLng()); });
      usBiblicalMarkers.forEach(m => { if (map.hasLayer(m)) bounds.extend(m.getLatLng()); });
      if (bounds.isValid()) { map.fitBounds(bounds); }
      else { console.log("No markers in bounds to zoom to."); }
    }
    document.getElementById("zoomAllBtn").onclick = zoomToAllMarkers;
    
    /*****************************************************
     * EVENT LISTENERS FOR TOGGLES (LAZY LOADING)
     *****************************************************/
    document.getElementById("toggleUSUK").addEventListener("change", updateMarkersVisibility);
    document.getElementById("toggleUSBiblical").addEventListener("change", updateMarkersVisibility);
    
    /*****************************************************
     * INITIAL UI SETUP
     *****************************************************/
    // Do not load any markers on page load.
    buildFilterPanel();
    setupCitySearch();
  </script>
</body>
</html>
